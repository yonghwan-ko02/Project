말씀하신 **제한사항(로컬 환경, 비용 0원, 유지보수 최소화)**과 **한계(하드웨어 성능, 할루시네이션)**를 모두 기술적으로 해결한 **구체적인 MVP(Minimum Viable Product) 기획안**을 제안해 드립니다.

대상 도서는 한국인에게 가장 익숙하고, 권선징악 구조가 뚜렷해 비틀기(Twist) 좋은 **《콩쥐팥쥐》**로 결정하겠습니다.

---

# 🚀 Project: 전래동화 리부트 (콩쥐의 선택)

### 1. 프로젝트 개요

* **목표:** 《콩쥐팥쥐》의 텍스트를 학습한 로컬 AI를 통해, 콩쥐가 되어 원작과 다른 선택을 하며 엔딩을 바꾸는 텍스트 어드벤처 게임.
* **실행 환경:** 인터넷 연결이 필요 없는 개인 노트북 (Local Host).
* **비용:** **0원** (Open Source 100% 활용).
* **핵심 컨셉:** "밑 빠진 독에 물 붓기를 거부한다면?" (원작 파괴 + 페르소나 유지)

---

### 2. 기술 스택 및 아키텍처 (제한사항 해결 중심)

가벼우면서도 강력한 최신 오픈소스 도구들을 조합합니다.

| 구분 | 도구(Tool) | 선정 이유 및 제한사항 해결법 |
| --- | --- | --- |
| **LLM 모델** | **Ollama (Llama-3.1-8b-instruct)** | **[비용/성능 해결]** 서버 비용 0원. 8B(80억 파라미터) 모델은 일반 노트북(RAM 8GB~16GB)에서도 쾌적하게 돌아가며 한국어 성능도 준수합니다. |
| **데이터 저장** | **ChromaDB** | **[유지보수 해결]** 별도 DB 설치(MySQL 등) 없이 로컬 폴더에 파일로 저장되는 임베딩 DB입니다. 관리가 매우 쉽습니다. |
| **프레임워크** | **LangChain** | **[구현 난이도 해결]** 복잡한 LLM 연동 과정을 파이썬 코드 몇 줄로 줄여주는 표준 프레임워크입니다. |
| **UI** | **Python Terminal (Console)** | **[리소스 최적화]** 화려한 그래픽을 배제하고 텍스트에 집중하여 로컬 컴퓨터의 부하를 최소화합니다. |

---

### 3. 데이터 구조 설계 (경영정보학과 관점)

유지보수를 줄이기 위해 책 데이터를 **'객체 지향적'**으로 구조화하여 저장합니다. 텍스트를 무작정 넣는 게 아니라, **속성(Metadata)**을 부여합니다.

#### A. 원본 데이터 (Source Data: story.txt)

저작권 만료된 콩쥐팥쥐 텍스트를 구해서 아래와 같이 문단별로 나눕니다.

#### B. 벡터 데이터베이스 스키마 (Vector DB Schema)

RAG(검색) 효율을 높이기 위해 메타데이터를 활용합니다.

* **Document (Content):** "팥쥐 엄마는 콩쥐에게 자갈밭을 매라고 시키고 팥쥐와 함께 나들이를 갔다."
* **Metadata (JSON):**
```json
{
  "source": "콩쥐팥쥐",
  "type": "event",       // event(사건), persona(성격), background(배경) 중 하나
  "character": ["팥쥐엄마", "콩쥐"],
  "emotion": "unfair"    // 억울함, 부당함
}

```


> **전략:** 게임 진행 중 "팥쥐 엄마"가 등장하면, AI는 `character: 팥쥐엄마` 태그가 달린 데이터 중 `type: persona`인 것을 우선 조회하여 말투를 흉내 냅니다.



---

### 4. 핵심 구현 로직 (객체 지향 설계)

코드는 복잡하게 짜지 않고, **3개의 핵심 클래스**로 구성합니다.

#### Class 1: `LoreKeeper` (지식 관리자)

* **책임:** 책 내용을 읽어서 DB에 넣고, 필요할 때 꺼내 주는 역할.
* **기능:**
* `load_book()`: 텍스트 파일 로딩 및 청킹.
* `retrieve(query)`: 현재 상황에 맞는 원작 내용 검색 (RAG).



#### Class 2: `DungeonMaster` (게임 마스터 AI)

* **책임:** 사용자의 입력을 받아 스토리를 생성하고 선택지를 제시.
* **핵심 프롬프트 설계:**
> "너는 TRPG 마스터야. 아래 **[참고자료]**에 있는 인물들의 성격을 바탕으로 이야기를 진행해. 단, **[사용자의 선택]**이 원작과 다르면 원작을 무시하고 새로운 인과관계를 만들어."



#### Class 3: `GameLoop` (메인 실행기)

* **책임:** 게임의 시작과 끝, 사용자 입력 대기.
* **한계 극복 로직 (Memory Management):**
* 대화가 길어지면 LLM이 앞 내용을 까먹는 **한계**가 발생함.
* **해결:** 최근 3번의 대화만 `History`에 남기고, 그 이전 대화는 "요약문(Summary)"으로 변환해서 프롬프트 맨 위에 고정함.



---

### 5. 현실적인 실행 시나리오 (User Flow)

1. **초기화:** 프로그램 실행 시 `story.txt`를 읽어 ChromaDB 생성 (최초 1회만 10초 소요).
2. **오프닝:** "당신은 콩쥐입니다. 새어머니가 밑 빠진 독에 물을 채우라고 시켰습니다. 두꺼비가 도와준다고 다가옵니다. 어떻게 하시겠습니까?"
3. **사용자 선택:** "두꺼비를 발로 차버리고 내가 직접 흙을 구워 독을 메운다." (원작 파괴 선택)
4. **AI 처리 (Internal Process):**
* **검색:** `두꺼비`, `성격` 검색 -> "두꺼비는 은혜를 갚으려 함" (참조)
* **생성:** "콩쥐의 예상치 못한 발길질에 두꺼비는 멀리 날아갔습니다. 콩쥐는 땀을 흘리며 진흙을 구워 독을 메웠습니다. 이를 본 새어머니는 콩쥐의 생활력에 놀라며..."


5. **다음 분기:** "새어머니가 이번엔 베 짜기를 시킵니다. 어떻게 할까요?" (선택지 1. 짠다 / 2. 도망간다 / 3. 파업한다)

---

### 6. 기대 효과 및 확장성

* **MVP 완성도:** 텍스트와 터미널만 사용하므로 버그가 적고, 로직 검증에 최적화되어 있습니다.
* **데이터 분석 연계:** 사용자가 어떤 선택지(순종적 vs 반항적)를 많이 고르는지 SQL로 로그를 저장해 **'플레이어 성향 분석'** 데이터로 활용할 수 있습니다. (기존 관심사와 연결)

---

### 다음 단계 (Next Step)

이 MVP를 바로 실행해 보실 수 있도록, 복잡한 설정 다 빼고 **"복사해서 붙여넣으면 바로 돌아가는" 파이썬 코드 프로토타입(하나의 파일)**을 작성해 드릴까요?

(Ollama만 설치되어 있으면 바로 실행 가능한 코드로 드리겠습니다.)