# Product Requirements Document (PRD)
## Project: 전래동화 리부트 (콩쥐의 선택)

| 문서 관리 정보 | 내용 |
| --- | --- |
| **작성일** | 2025-12-23 |
| **상태** | Draft |
| **기반 문서** | [Ideation.md](./Ideation.md) |

---

## 1. 프로젝트 개요 (Project Overview)

### 1.1 목표 (Goal)
한국인에게 친숙한 전래동화 **《콩쥐팥쥐》**를 기반으로, 사용자가 주인공 '콩쥐'가 되어 원작과 다른 선택을 함으로써 새로운 결말을 만들어가는 **텍스트 어드벤처 게임**을 개발한다.

### 1.2 핵심 컨셉 (Core Concept)
*   **"밑 빠진 독에 물 붓기를 거부한다면?"**
*   원작의 권선징악 구조를 비틀기(Twist) 가능한 자유도 제공.
*   원작 캐릭터의 페르소나(성격)는 유지하되, 전개는 사용자의 상상력에 따라 변화.

---

## 2. 제약 조건 및 요구사항 (Constraints & Requirements)

이 프로젝트는 다음 3가지 핵심 제약 조건을 기술적으로 해결하는 것을 전제로 한다.

1.  **로컬 환경 (Local Environment):** 인터넷 연결 없이 개인 노트북(Local Host)에서 완벽하게 구동되어야 한다.
2.  **비용 0원 (Zero Cost):** 서버 비용이나 API 사용료가 발생하지 않는 100% 오픈소스/로컬 모델을 사용한다.
3.  **유지보수 최소화 (Minimal Maintenance):** 복잡한 DB 관리 없이 파일 기반의 구조를 지향한다.

### 2.1 하드웨어 권장 사양
*   **OS:** Windows, Mac, Linux
*   **RAM:** 8GB ~ 16GB (일반 소비자용 노트북 기준)

---

## 3. 기술 스택 및 아키텍처 (Tech Stack & Architecture)

로컬 환경 최적화와 비용 절감을 위해 다음과 같은 기술 스택을 선정한다.

| 구분 | 도구 (Tool) | 선정 이유 |
| --- | --- | --- |
| **LLM Model** | **Ollama (Llama-3.1-8b-instruct)** | 8B 파라미터 모델로 일반 노트북 구동 가능, 준수한 한국어 성능, 비용 0원. |
| **Vector DB** | **ChromaDB** | 별도 서버 프로세스 없이 로컬 파일로 저장되는 임베딩 DB. 유지보수 용이. |
| **Framework** | **LangChain** | LLM 연동 및 RAG 파이프라인 구축을 위한 표준 프레임워크. |
| **UI** | **Python Terminal (Console)** | GUI 리소스를 배제하고 텍스트 생성 성능에 집중하기 위해 터미널 인터페이스 채택. |

---

## 4. 데이터 구조 및 모델링 (Data Structure)

유지보수성과 RAG(검색 증강 생성) 효율을 높이기 위해 객체 지향적 메타데이터 구조를 사용한다.

### 4.1 원본 데이터 (Source)
*   저작권이 만료된 《콩쥐팥쥐》 원문 텍스트 파일 (`.txt`).

### 4.2 벡터 DB 스키마 (Metadata Schema)
텍스트 청크(Chunk)별로 아래와 같은 메타데이터를 태깅하여 저장한다.

*   `source`: 출처 (예: "콩쥐팥쥐")
*   `type`: 데이터 유형 (`event`, `persona`, `background`)
*   `character`: 관련 등장인물 리스트 (예: `["팥쥐엄마", "콩쥐"]`)
*   `emotion`: 텍스트 당시에 내포된 감정 (예: `unfair`, `sad`)

**활용 전략:**
게임 진행 중 특정 인물(예: 팥쥐 엄마) 등장 시, `character: 팥쥐엄마` AND `type: persona` 조건으로 검색하여 해당 인물의 말투와 성격을 일관되게 유지한다.

---

## 5. 핵심 기능 요구사항 (Functional Requirements)

시스템은 다음 3가지 핵심 모듈(Class)로 구성된다.

### 5.1 LoreKeeper (지식 관리자)
*   **데이터 로딩:** `story.txt`를 읽어 문단 단위로 분리(Chunking)한다.
*   **임베딩:** 분리된 텍스트를 벡터화하여 ChromaDB에 저장한다 (최초 실행 시).
*   **검색(RAG):** 현재 게임 상황(Query)에 가장 적합한 원작 내용이나 캐릭터 정보를 검색하여 반환한다.

### 5.2 DungeonMaster (게임 마스터 AI)
*   **스토리 텔링:** 사용자의 입력과 검색된 Lore를 바탕으로 다음 이야기를 생성한다.
*   **인과관계 처리:**
    *   사용자 선택이 원작과 유사함 -> 원작 흐름 유지.
    *   사용자 선택이 원작과 다름 -> 원작 설정을 무시하고 새로운 인과관계 생성 (단, 캐릭터 성격은 유지).
*   **프롬프트 제어:** "너는 TRPG 마스터다"라는 시스템 프롬프트를 기반으로 롤플레잉을 수행한다.

### 5.3 GameLoop (메인 실행기)
*   **인터페이스:** 턴제 방식의 텍스트 입출력(I/O)을 처리한다.
*   **메모리 관리 (Memory Management):**
    *   LLM의 컨텍스트 길이 제한(Context Window) 극복을 위해 '최근 3턴'만 원본 대화를 유지한다.
    *   오래된 대화는 **요약(Summary)** 형태로 변환하여 프롬프트 상단에 고정한다.

---

## 6. 사용자 흐름 (User Flow)

1.  **초기화 (Init):** 프로그램 실행 시 DB 로딩 (최초 1회 임베딩 생성 시 약 10초 소요).
2.  **오프닝 (Opening):** "밑 빠진 독에 물 붓기" 씬 출력. 두꺼비 등장.
3.  **사용자 입력 (Input):** 사용자가 행동을 선택하거나 직접 입력 (예: "두꺼비를 발로 찬다").
4.  **처리 (Process):**
    *   `LoreKeeper`가 '두꺼비'의 성격('은혜 갚음') 검색.
    *   `DungeonMaster`가 상황 판단: "두꺼비를 찼으므로 은혜를 갚지 못하고 날아감."
5.  **결과 출력 (Output):** 변경된 스토리 출력 및 다음 위기(베 짜기) 제시.
6.  **반복 (Loop):** 엔딩에 도달할 때까지 3~5 과정을 반복.

---

## 7. 기대 효과
*   로컬 LLM 기반의 인터랙티브 스토리텔링 기술 검증.
*   데이터 로그 분석을 통한 플레이어 성향 데이터(순종적 vs 반항적) 확보 가능.
